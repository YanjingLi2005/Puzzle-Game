<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ç¢ç‰‡å¯»è¸ª - æ¸¸æˆä¸»é¡µ</title>
  <style>
    body {
      font-family: 'Press Start 2P', monospace;
      background-color: #fffbe6;
      color: #333;
      text-align: center;
      padding: 20px;
    }
    h1 {
      color: #ffcc00;
      text-shadow: 1px 1px 2px #aaa;
    }
    .button {
      display: inline-block;
      margin: 10px;
      padding: 10px 20px;
      font-size: 14px;
      background-color: #ffd633;
      border: none;
      border-radius: 10px;
      box-shadow: 2px 2px 0 #aaa;
      cursor: pointer;
      font-family: 'Press Start 2P', monospace;
      user-select: none;
    }
    .fragment-counter {
      font-size: 16px;
      margin-top: 20px;
    }
    canvas {
      border: 2px dashed #ccc;
      margin-top: 20px;
      border-radius: 15px;
      background: linear-gradient(to top, #87ceeb 0%, #a0d8ef 70%, #ffffff 100%);
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
    #puzzle {
      width: 320px;
      height: 320px;
      margin: 20px auto;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 1px;
    }
    .tile {
      width: 80px;
      height: 80px;
      background-size: 320px 320px;
      border: 1px solid #ccc;
      cursor: grab;
      user-select: none;
    }
    #message {
      font-size: 18px;
      margin-top: 15px;
      color: #e67300;
      font-weight: bold;
      min-height: 24px;
    }
    .weather-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
</head>
<body>
  <h1>ç¢ç‰‡å¯»è¸ª</h1>
  <p>ç”Ÿæ—¥å¿«ä¹ï¼Œé™æ€¡å®å®ï¼è¿™æ˜¯ä¸€ä¸ª Puzzle Adventure! æœ€è¿‘å®å®ç»ƒè½¦å¿™å¿™çš„ï¼Œæˆ‘æ¯å¤©å­¦å®Œä¹ æƒ³ä½ äº†å°±åšä¸€ä¼šå„¿è¿™ä¸ªç¤¼ç‰©ï¼Œå°±è§‰å¾—å¿ƒå¾ˆå……å®ã€‚é€‰æ‹©ä½ çš„æŒ‘æˆ˜ï¼š</p>

  <div>
    <button class="button" onclick="startGastownPuzzle()">Gastown æ‹¼å›¾</button>
    <button class="button" onclick="startFlightGame()">èˆªçº¿å¤§ä½œæˆ˜</button>
    <button class="button" onclick="startKayakGame()">çš®åˆ’è‰‡æŒ‘æˆ˜</button>
    <button class="button" onclick="startLegolandPetGame()">ä¹é«˜å® ç‰©å…»æˆ</button>
  </div>

  <div class="fragment-counter" id="fragmentCounter">å½“å‰ç¢ç‰‡ï¼š0 / 5</div>

  <div id="game-container"></div>

  <script>
    let fragmentCount = 0;
    const container = document.getElementById("game-container");
    const counter = document.getElementById("fragmentCounter");

    function drawSimplePixelDaisy(ctx, x, y, pixelSize = 6) {
      // é¢œè‰²
      const yellow = '#FFD700';
      const white = '#FFFFFF';
      const green = '#228B22';
      const black = '#000000';
    
      // æ¸…ç©ºç”»å¸ƒ
      ctx.clearRect(x, y, 16 * pixelSize, 16 * pixelSize);
    
      // èŠ±ç“£ä¸­å¿ƒç‚¹ï¼ˆç™½è‰²ï¼‰
      const petals = [
        [7,3],[8,3],[6,4],[9,4],[5,5],[10,5],[5,6],[10,6],[6,7],[9,7],[7,8],[8,8]
      ];
    
      // èŠ±å¿ƒï¼ˆé»„è‰²ï¼‰
      const center = [
        [7,5],[8,5],[7,6],[8,6]
      ];
    
      // èŒï¼ˆç»¿è‰²ï¼‰
      const stem = [
        [7,9],[8,9],[7,10],[8,10]
      ];
    
      // ç”»èŠ±ç“£
      ctx.fillStyle = white;
      petals.forEach(([px, py]) => {
        ctx.fillRect(x + px * pixelSize, y + py * pixelSize, pixelSize, pixelSize);
        ctx.strokeRect(x + px * pixelSize, y + py * pixelSize, pixelSize, pixelSize);
      });
    
      // ç”»èŠ±å¿ƒ
      ctx.fillStyle = yellow;
      center.forEach(([px, py]) => {
        ctx.fillRect(x + px * pixelSize, y + py * pixelSize, pixelSize, pixelSize);
        ctx.strokeRect(x + px * pixelSize, y + py * pixelSize, pixelSize, pixelSize);
      });
    
      // ç”»èŒ
      ctx.fillStyle = green;
      stem.forEach(([px, py]) => {
        ctx.fillRect(x + px * pixelSize, y + py * pixelSize, pixelSize, pixelSize);
        ctx.strokeRect(x + px * pixelSize, y + py * pixelSize, pixelSize, pixelSize);
      });
    
      // é»‘è‰²è¾¹æ¡†
      ctx.strokeStyle = black;
    }
    
    
  
  const canvas = document.createElement('canvas');
canvas.width = 16 * 6;
canvas.height = 16 * 6;
document.body.appendChild(canvas);
const ctx = canvas.getContext('2d');
drawSimplePixelDaisy(ctx, 0, 0, 6);


    function updateCounter() {
      counter.innerText = `å½“å‰ç¢ç‰‡ï¼š${fragmentCount} / 5`;
    }

    // === Gastown æ‹¼å›¾ ===
    function startGastownPuzzle() {
      container.innerHTML = `
        <h2>Gastown å¤œé—´æ‹¼å›¾</h2>
        <p>æ‹–åŠ¨æ¯å—æ‹¼å›¾åˆ°æ­£ç¡®çš„ä½ç½®ã€‚å…± 4x4 æ‹¼å›¾ï¼Œè¯·è®¤çœŸè§‚å¯Ÿå›¾æ¡ˆï¼</p>
        <div id="puzzle"></div>
        <p id="message"></p>
      `;

      const puzzle = document.getElementById("puzzle");
      const message = document.getElementById("message");
      const size = 4;
      let tiles = [];

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const tile = document.createElement("div");
          tile.className = "tile";
          tile.style.backgroundImage = "url('https://i.imgur.com/5LNUa1Q.png')";
          tile.style.backgroundPosition = `-${x * 80}px -${y * 80}px`;
          tile.dataset.correct = `${y * size + x}`;
          tiles.push(tile);
        }
      }

      tiles.sort(() => Math.random() - 0.5);
      tiles.forEach((tile, idx) => {
        tile.dataset.index = idx;
        tile.draggable = true;
        tile.addEventListener("dragstart", dragStart);
        tile.addEventListener("dragover", dragOver);
        tile.addEventListener("drop", drop);
        puzzle.appendChild(tile);
      });

      let dragged;

      function dragStart(e) {
        dragged = e.target;
      }

      function dragOver(e) {
        e.preventDefault();
      }

      function drop(e) {
        e.preventDefault();
        if (dragged !== e.target) {
          const from = dragged.dataset.index;
          const to = e.target.dataset.index;

          puzzle.insertBefore(dragged, puzzle.children[to]);
          puzzle.insertBefore(e.target, puzzle.children[from]);

          updateIndices();
          checkWin();
        }
      }

      function updateIndices() {
        Array.from(puzzle.children).forEach((tile, idx) => {
          tile.dataset.index = idx;
        });
      }

      function checkWin() {
        const isCorrect = Array.from(puzzle.children).every((tile, idx) => tile.dataset.correct == idx);
        if (isCorrect) {
          message.textContent = "ğŸ‰ æ‹¼å›¾æˆåŠŸï¼ä½ è·å¾—äº†ä¸€ä¸ªç¢ç‰‡ï¼";
          fragmentCount++;
          updateCounter();
        } else {
          message.textContent = "";
        }
      }
    }

    // === èˆªçº¿å¤§ä½œæˆ˜ 
    function startFlightGame() {
      container.innerHTML = `
        <h2>èˆªçº¿å¤§ä½œæˆ˜ï¼šç»ˆææŒ‘æˆ˜ âœˆï¸</h2>
        <p>ä»<strong>åœ£åœ°äºšå“¥</strong>å‡ºå‘ï¼Œé©¾é©¶é£æœºï¼Œæ”¶é›†å¯†ç ç¢ç‰‡åå‰å¾€<strong>æ¸©å“¥åæœºåœº</strong>ï¼</p>
        <div id="hintArea" style="background:#f0f0f0; padding:10px; border-radius:5px; margin:10px 0;">
          <p id="hintText">æç¤ºï¼šæ”¶é›†æ‰€æœ‰å¯†ç ç¢ç‰‡(ğŸ”¢)ã€‚ç¢ç‰‡åˆå§‹ä¸ºâ€œï¼Ÿâ€</p>
          <p id="timer" style="font-weight:bold;">å‰©ä½™æ—¶é—´: 60ç§’</p>
        </div>
        <canvas id="mazeCanvas" width="600" height="600"></canvas>
        <div id="message" style="min-height:40px;"></div>
        <div id="passwordDisplay" style="font-size:18px; margin:10px 0; letter-spacing:5px;">å¯†ç : _ _ _ _</div>
        <div id="scoreDisplay" style="font-size:16px;">æ”¶é›†: 0/4 å¯†ç ç¢ç‰‡</div>
      `;
    

      const canvas = document.getElementById("mazeCanvas"), ctx = canvas.getContext("2d");
      const message = document.getElementById("message"), hintText = document.getElementById("hintText");
      const passwordDisplay = document.getElementById("passwordDisplay"), scoreDisplay = document.getElementById("scoreDisplay");
      const timerDisplay = document.getElementById("timer");
    

      const tileSize = 60, rows = 10, cols = 10;
      let grid, x, y, lastDir, passwordPieces, collectedDigits, revealedDigits, timeLeft, gameActive;
      let movingWalls, moveTick = 0;
    
      const password = "1904";
    
      const passwordPiecesPositions = shuffle([
        {x: 1, y: 7, digit: '1'},
        {x: 4, y: 3, digit: '9'},
        {x: 7, y: 4, digit: '0'},
        {x: 6, y: 8, digit: '4'}
      ]);
    
      function initGame() {
        grid = [
          [1,1,1,1,1,1,1,1,1,1],
          [1,0,0,0,1,0,0,0,0,1],
          [1,0,1,0,1,0,1,0,1,1],
          [1,0,1,0,0,0,1,0,0,1],
          [1,0,1,1,1,0,1,1,0,1],
          [1,0,0,0,1,0,0,1,0,1],
          [1,1,1,0,1,1,0,1,0,1],
          [1,0,0,0,0,0,0,1,0,1],
          [1,0,1,1,1,1,0,0,0,1],
          [1,1,1,1,1,1,1,1,1,1],
        ];
    
        // æ·»åŠ ç»ˆç‚¹ï¼ˆæ¸©å“¥åæœºåœºï¼‰
        grid[1][8] = 2;
    
        x = 1; y = 1; lastDir = "right"; passwordPieces = 0;
        collectedDigits = [null, null, null, null];
        revealedDigits = {}; 
        timeLeft = 60; gameActive = true;
    
        movingWalls = [
          {x: 5, y: 2, dir: 1},
          {x: 6, y: 5, dir: -1}
        ];
    
        passwordPiecesPositions.forEach(p => {
          grid[p.y][p.x] = 3;
        });
    
        updateUI(); startTimer(); draw(); gameLoop();
      }
    
      function shuffle(arr) {
        return arr.map(v => [v, Math.random()]).sort((a, b) => a[1] - b[1]).map(p => p[0]);
      }
    
      function updateUI() {
        scoreDisplay.textContent = `æ”¶é›†: ${passwordPieces}/4 å¯†ç ç¢ç‰‡`;
        timerDisplay.textContent = `å‰©ä½™æ—¶é—´: ${timeLeft}ç§’`;
        passwordDisplay.textContent = "å¯†ç : " + collectedDigits.map(d => d || '_').join(' ');
      }
    
      function startTimer(){
        const timer = setInterval(()=>{
          if (!gameActive) { clearInterval(timer); return; }
          timeLeft--; updateUI();
          if(timeLeft <= 0){ gameOver(false); clearInterval(timer); }
        }, 1000);
      }
    
      function moveWalls(){
        moveTick++;
        if (moveTick % 20 !== 0) return;
        movingWalls.forEach(w => {
          const ny = w.y + w.dir;
          if(ny > 1 && ny < rows - 1 && grid[ny][w.x] === 0) {
            w.y = ny;
          } else {
            w.dir *= -1;
          }
        });
      }
    
      function draw(){
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff8dc";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    
        ctx.strokeStyle = "#ddd";
        for(let i = 0; i <= rows; i++){
          ctx.beginPath();
          ctx.moveTo(0, i * tileSize);
          ctx.lineTo(canvas.width, i * tileSize);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(i * tileSize, 0);
          ctx.lineTo(i * tileSize, canvas.height);
          ctx.stroke();
        }
    
        for(let i = 0; i < rows; i++){
          for(let j = 0; j < cols; j++){
            if(grid[i][j] === 1){
              ctx.fillStyle = "#ffcc66";
              ctx.fillRect(j * tileSize, i * tileSize, tileSize, tileSize);
            } else if (grid[i][j] === 2) {
              ctx.fillStyle = "#00bcd4";
              ctx.fillRect(j * tileSize + tileSize * 0.2, i * tileSize + tileSize * 0.2, tileSize * 0.6, tileSize * 0.6);
              ctx.fillStyle = "#fff";
              ctx.font = `${tileSize / 2}px Arial`;
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText("ğŸ", j * tileSize + tileSize / 2, i * tileSize + tileSize / 2);
            } else if (grid[i][j] === 3) {
              const piece = passwordPiecesPositions.find(p => p.x === j && p.y === i);
              const key = `${j},${i}`;
              ctx.fillStyle = "#ff5722";
              ctx.beginPath();
              ctx.arc(j * tileSize + tileSize / 2, i * tileSize + tileSize / 2, tileSize / 4, 0, 2 * Math.PI);
              ctx.fill();
    
              ctx.fillStyle = "#fff";
              ctx.font = `${tileSize / 2}px Arial`;
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(revealedDigits[key] || "?", j * tileSize + tileSize / 2, i * tileSize + tileSize / 2);
            }
          }
        }
    
        movingWalls.forEach(w=>{
          ctx.fillStyle = "#8B4513";
          ctx.fillRect(w.x * tileSize + tileSize * 0.1, w.y * tileSize + tileSize * 0.1, tileSize * 0.8, tileSize * 0.8);
        });
    
        const cx = x * tileSize + tileSize / 2, cy = y * tileSize + tileSize / 2;
        ctx.save();
        ctx.translate(cx, cy);
        const angle = lastDir === "up" ? -Math.PI/2 : lastDir === "down" ? Math.PI/2 : lastDir === "left" ? Math.PI : 0;
        ctx.rotate(angle);
        ctx.fillStyle = "#e60000";
        ctx.beginPath();
        ctx.moveTo(0, -tileSize * 0.2);
        ctx.lineTo(tileSize * 0.2, tileSize * 0.2);
        ctx.lineTo(-tileSize * 0.2, tileSize * 0.2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    
      function gameOver(win){
        gameActive = false;
        message.innerHTML = win ? "ğŸ‰ æ­å–œï¼Œå¯†ç æ­£ç¡®ï¼Œæ¸¸æˆèƒœåˆ©ï¼" : "<strong>â± æ—¶é—´åˆ°ï¼å¤±è´¥ï¼</strong>";
        if(win){
          setTimeout(() => {
            alert(`å¯¹ä¸èµ·ï¼Œæ€»ç¦»ä½ é‚£ä¹ˆè¿œã€‚`);
          }, 300);
        }
      }
    
    
        function keyHandler(e){
          if(!gameActive) return;
          const moves = {
            ArrowUp: [0, -1, "up"],
            ArrowDown: [0, 1, "down"],
            ArrowLeft: [-1, 0, "left"],
            ArrowRight: [1, 0, "right"]
          };
          if(!moves[e.key]) return;
          const [dx, dy, dir] = moves[e.key];
          lastDir = dir;
          const nx = x + dx, ny = y + dy;
        
          // âœ… å…ˆæ£€æµ‹æ’åˆ°ç§»åŠ¨å¢™ï¼ˆåˆ«æ”¾åé¢ï¼‰
          if(movingWalls.some(w => w.x === nx && w.y === ny)){
            x = 1; y = 1;
            message.textContent = "ğŸ’¥ æ’ä¸Šç§»åŠ¨å¢™ï¼Œè¿”å›åœ£åœ°äºšå“¥ï¼";
            updateUI();
            return;
          }
        
          // æ™®é€šå¢™ä½“ç¢°æ’æ£€æµ‹
          if(nx < 0 || nx >= cols || ny < 0 || ny >= rows || grid[ny][nx] === 1) return;
        
          x = nx; y = ny;
        
          // âœ… ç¢°åˆ°å¯†ç ç¢ç‰‡
          if(grid[y][x] === 3){
            const key = `${x},${y}`;
            const piece = passwordPiecesPositions.find(p => p.x === x && p.y === y);
            if(piece){
              grid[y][x] = 0;
              revealedDigits[key] = piece.digit;
              const index = passwordPiecesPositions.indexOf(piece);
              collectedDigits[index] = piece.digit;
              passwordPieces++;
              updateUI();
        
              if(passwordPieces === 4){
                hintText.innerHTML = `<strong>æç¤ºï¼š</strong>å‰å¾€æ¸©å“¥åæœºåœºï¼Œå¹¶è¾“å…¥å¯†ç ã€‚`;
              }
            }
          }
        
          // âœ… ç»ˆç‚¹å¤„ç†
          if(grid[y][x] === 2){
            if(passwordPieces < 4){
              message.textContent = "âš ï¸ è¯·å…ˆæ”¶é›†å…¨éƒ¨å¯†ç ç¢ç‰‡";
            } else {
              setTimeout(() => {
                const inp = prompt("è¯·è¾“å…¥4ä½å¯†ç ");
                if(inp === password){ 
                  gameOver(true);
                } else {
                  message.textContent = "âŒ å¯†ç é”™è¯¯ï¼æ­£ç¡®å¯†ç æ˜¯ 1904";
                }
              }, 10);
            }
          }
      
        
    
        if(grid[y][x] === 2){
          if(passwordPieces < 4){
            message.textContent = "âš ï¸ è¯·å…ˆæ”¶é›†å…¨éƒ¨å¯†ç ç¢ç‰‡";
          } else {
            setTimeout(() => {
              const inp = prompt("è¯·è¾“å…¥4ä½å¯†ç ");
              if(inp === password){ 
                gameOver(true);
              } else {
                message.textContent = "âŒ å¯†ç é”™è¯¯ï¼æ­£ç¡®å¯†ç æ˜¯ 1904";
              }
            }, 10);
          }
        }
      }
    
      function gameLoop(){
        if(gameActive){
          moveWalls();
          draw();
        }
        requestAnimationFrame(gameLoop);
      }
    
      document.removeEventListener("keydown", keyHandler);
      document.addEventListener("keydown", keyHandler);
      initGame();
    }
    
    // === ä¹é«˜å® ç‰©å…»æˆ ===

    function startLegolandPetGame() {
      const container = document.getElementById('game-container');
      container.innerHTML = `
        <h2>ä¹é«˜ä¹å›­ï¼šç§¯æœ¨å® ç‰©å…»æˆ ğŸ¾</h2>
        <p>ç”¨æ–¹å‘é”®ç§»åŠ¨ç§¯æœ¨å°äººï¼Œé è¿‘ç§¯æœ¨å® ç‰©äº’åŠ¨ï¼Œç»™å®ƒå–‚é£Ÿç§¯æœ¨å—å§ï¼</p>
        <canvas id="petCanvas" width="400" height="400" style="background:#d0f0c0; display:block; margin: 20px auto; border: 3px solid #4CAF50; border-radius: 15px;"></canvas>
        <div id="petStatus" style="font-family: 'Press Start 2P', monospace; font-size: 16px; color:#336633; margin-top:10px;">
          ç§¯æœ¨å—ï¼ˆé£Ÿç‰©ï¼‰ï¼š0 / 5 | å® ç‰©å¿ƒæƒ…ï¼šğŸ˜Š
        </div>
      `;
    
      const canvas = document.getElementById('petCanvas');
      const ctx = canvas.getContext('2d');
    
      const gridSize = 40;
      const gridCount = 10;
    
      let player = { x: 0, y: 0 };
      let pet = { x: 5, y: 5, mood: 5 }; // mood 0-10
      let foodBlocks = [];
      const maxFood = 5;
      let collectedFood = 0;
    
      function randomGridPosition() {
        return {
          x: Math.floor(Math.random() * gridCount),
          y: Math.floor(Math.random() * gridCount)
        };
      }
    
      // åˆå§‹åŒ–é£Ÿç‰©å—éšæœºæ•£å¸ƒï¼Œä¸å’Œç©å®¶å® ç‰©é‡å 
      while (foodBlocks.length < maxFood) {
        let pos = randomGridPosition();
        if (
          !(pos.x === player.x && pos.y === player.y) &&
          !(pos.x === pet.x && pos.y === pet.y) &&
          !foodBlocks.some(f => f.x === pos.x && f.y === pos.y)
        ) {
          foodBlocks.push(pos);
        }
      }
    
      function drawGrid() {
        ctx.strokeStyle = '#a3c293';
        for (let i = 0; i <= gridCount; i++) {
          ctx.beginPath();
          ctx.moveTo(i * gridSize, 0);
          ctx.lineTo(i * gridSize, gridCount * gridSize);
          ctx.stroke();
    
          ctx.beginPath();
          ctx.moveTo(0, i * gridSize);
          ctx.lineTo(gridCount * gridSize, i * gridSize);
          ctx.stroke();
        }
      }
    
      function drawPlayer() {
        const x = player.x * gridSize;
        const y = player.y * gridSize;
        ctx.fillStyle = '#ff9966'; // æ©™è‰²ç§¯æœ¨äºº
        ctx.fillRect(x + 10, y + 10, gridSize - 20, gridSize - 20);
        // çœ¼ç›
        ctx.fillStyle = '#000';
        ctx.fillRect(x + 18, y + 18, 5, 5);
        ctx.fillRect(x + 27, y + 18, 5, 5);
      }
    
      function drawPet() {
        const x = pet.x * gridSize;
        const y = pet.y * gridSize;
    
        // å® ç‰©æ ¹æ®å¿ƒæƒ…é¢œè‰²å˜åŒ–
        let baseColor = pet.mood > 7 ? '#66cc66' : pet.mood > 3 ? '#99cc99' : '#cccccc';
        ctx.fillStyle = baseColor;
    
        ctx.fillRect(x + 8, y + 8, gridSize - 16, gridSize - 16);
    
        // å® ç‰©çœ¼ç›ï¼ˆç®€å•è¡¨æƒ…ï¼‰
        ctx.fillStyle = pet.mood > 4 ? '#000' : '#666666';
        ctx.fillRect(x + 15, y + 20, 6, 6);
        ctx.fillRect(x + 27, y + 20, 6, 6);
    
        // å¦‚æœé è¿‘ç©å®¶ï¼Œå® ç‰©â€œè·³è·ƒâ€è¡¨ç°äº’åŠ¨
        if (Math.abs(player.x - pet.x) <= 1 && Math.abs(player.y - pet.y) <= 1) {
          ctx.fillStyle = '#ffaa00';
          ctx.beginPath();
          ctx.arc(x + gridSize/2, y + 5, 8, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    
      function drawFood() {
        foodBlocks.forEach(f => {
          const x = f.x * gridSize;
          const y = f.y * gridSize;
          ctx.fillStyle = '#ff4444'; // çº¢è‰²å°ç§¯æœ¨å—å½“é£Ÿç‰©
          ctx.fillRect(x + 15, y + 15, gridSize - 30, gridSize - 30);
        });
      }
    
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawFood();
        drawPlayer();
        drawPet();
      }
    
      function updateStatus() {
        const status = document.getElementById('petStatus');
        let moodEmoji = 'ğŸ˜';
        if (pet.mood > 7) moodEmoji = 'ğŸ˜Š';
        else if (pet.mood < 3) moodEmoji = 'ğŸ˜¢';
    
        status.textContent = `ç§¯æœ¨å—ï¼ˆé£Ÿç‰©ï¼‰ï¼š${collectedFood} / ${maxFood} | å® ç‰©å¿ƒæƒ…ï¼š${moodEmoji}`;
      }
    
      function movePlayer(dx, dy) {
        const nx = player.x + dx;
        const ny = player.y + dy;
        if (nx >= 0 && nx < gridCount && ny >= 0 && ny < gridCount) {
          player.x = nx;
          player.y = ny;
    
          // æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
          let idx = foodBlocks.findIndex(f => f.x === nx && f.y === ny);
          if (idx !== -1) {
            foodBlocks.splice(idx, 1);
            collectedFood++;
            pet.mood = Math.min(10, pet.mood + 2); // å–‚é£Ÿæå‡å¿ƒæƒ…
            updateStatus();
          }
    
          draw();
        }
        // å¦‚æœé è¿‘å® ç‰©ä¸”è¿˜æ²¡ç­”é¢˜
    if (Math.abs(player.x - pet.x) <= 1 && Math.abs(player.y - pet.y) <= 1 && collectedFood < maxFood) {
  askPetQuestions((canFeed) => {
    if (canFeed) {
      // ç”Ÿæˆä¸€ä¸ªæ–°çš„é£Ÿç‰©
      let newFood;
      do {
        newFood = randomGridPosition();
      } while (
        foodBlocks.some(f => f.x === newFood.x && f.y === newFood.y) ||
        (newFood.x === player.x && newFood.y === player.y) ||
        (newFood.x === pet.x && newFood.y === pet.y)
      );
      foodBlocks.push(newFood);
      draw();
    }
  });
}

      }


// æ•°ç‹¬é¢˜åº“æ”¾å…¨å±€
const sudokuPuzzles = {
  easy: [
    [
      [8,0,0,6,1,2,0,4,0],
      [5,0,0,0,0,8,0,1,0],
      [1,0,0,0,3,5,2,8,0],
      [0,8,0,0,0,0,4,0,9],
      [0,1,0,8,4,9,0,3,2],
      [0,4,0,3,2,0,0,0,0],
      [0,7,0,2,5,0,1,0,0],
      [4,2,1,0,7,0,5,0,0],
      [0,0,0,1,8,0,0,0,0]
    ]
  ],
  medium: [
    [
      [0,3,0,0,7,0,2,0,5],
      [7,0,0,1,0,4,0,0,0],
      [0,0,2,0,9,0,8,1,0],
      [0,8,6,0,0,0,0,0,4],
      [0,0,0,3,0,0,6,8,0],
      [0,0,0,0,0,0,0,7,0],
      [0,1,4,0,0,5,0,0,2],
      [0,0,5,4,0,0,1,9,8],
      [2,0,0,0,0,0,0,5,6]
    ]
  ],
  hard: [
    [
      [0,0,0,0,0,4,7,0,0],
      [5,0,4,0,0,0,0,0,0],
      [2,0,8,0,0,6,0,4,9],
      [0,0,7,0,0,0,0,5,0],
      [9,4,0,0,0,0,0,1,0],
      [3,0,0,0,0,0,0,0,0],
      [0,5,0,0,6,0,0,0,0],
      [0,8,0,0,0,3,0,9,0],
      [0,3,2,0,0,0,6,8,0]
    ]
  ]
};

function generateSudokuHTML(board) {
  let html = '<table style="border-collapse: collapse;">';
  for(let i=0; i<9; i++) {
    html += '<tr>';
    for(let j=0; j<9; j++) {
      const val = board[i][j];
      if(val !== 0) {
        html += `<td><input type="text" maxlength="1" value="${val}" readonly style="width:24px; height:24px; text-align:center; background:#eee; border:1px solid #ccc;"></td>`;
      } else {
        html += `<td><input type="text" maxlength="1" value="" style="width:24px; height:24px; text-align:center; border:1px solid #ccc;"></td>`;
      }
    }
    html += '</tr>';
  }
  html += '</table>';
  return html;
}

function askPetQuestions(callback) {
  let currentIndex = 0;
  let answersCorrect = 0;
  let difficulty = null;

  // å…ˆå¼¹å‡ºéš¾åº¦é€‰æ‹©æ¡†
  const diffPopup = document.createElement('div');
  diffPopup.style.position = 'fixed';
  diffPopup.style.top = '50%';
  diffPopup.style.left = '50%';
  diffPopup.style.transform = 'translate(-50%, -50%)';
  diffPopup.style.background = '#fff';
  diffPopup.style.padding = '20px';
  diffPopup.style.border = '2px solid #666';
  diffPopup.style.zIndex = '10000';
  diffPopup.style.fontFamily = "'Press Start 2P', monospace";
  diffPopup.innerHTML = `
    <p>è¯·é€‰æ‹©éš¾åº¦ç­‰çº§ï¼š</p>
    <button id="diffEasy">ç®€å•</button>
    <button id="diffMedium">ä¸­ç­‰</button>
    <button id="diffHard">å›°éš¾</button>
    <button id="diffCancel" style="color:red;">å–æ¶ˆ</button>
  `;
  document.body.appendChild(diffPopup);

  function startQuestions() {
    document.body.removeChild(diffPopup);
    askNext();
  }

  document.getElementById('diffEasy').onclick = () => { difficulty = 'easy'; startQuestions(); };
  document.getElementById('diffMedium').onclick = () => { difficulty = 'medium'; startQuestions(); };
  document.getElementById('diffHard').onclick = () => { difficulty = 'hard'; startQuestions(); };
  document.getElementById('diffCancel').onclick = () => {
    document.body.removeChild(diffPopup);
    alert('å–æ¶ˆç­”é¢˜ï¼Œæ— æ³•å–‚é£Ÿå® ç‰©ã€‚');
    callback(false);
  };

  function validateSudokuInput(popup) {
    // ç®€å•æ ¡éªŒï¼šæ£€æŸ¥ç©ºè¾“å…¥å’Œéæ•°å­—
    const inputs = popup.querySelectorAll('input:not([readonly])');
    for(let input of inputs) {
      if(input.value.trim() === '' || isNaN(input.value) || input.value < 1 || input.value > 9) {
        alert('è¯·å¡«å†™1-9çš„æ•°å­—ï¼Œä¸å…è®¸ä¸ºç©º');
        return false;
      }
    }
    return true;
  }

  function askNext() {
    // è¿™é‡Œåªæœ‰ä¸€é“æ•°ç‹¬é¢˜ï¼Œå¾ªç¯ä¸€æ¬¡å°±ç»“æŸ
    if (currentIndex >= 1) {
      if (answersCorrect >= 1) {
        alert('å…¨éƒ¨ç­”å¯¹ï¼å¯ä»¥å–‚å® ç‰©å•¦ ğŸ—');
        callback(true);
      } else {
        alert('æœ‰äº›æ²¡ç­”å¯¹å‘¢ï¼Œå†è¯•è¯•å§ï¼ğŸ¾');
        callback(false);
      }
      return;
    }

    // å–å‡ºæ•°ç‹¬é¢˜ç›®
    const sudokuBoard = sudokuPuzzles[difficulty][0];
    if(!sudokuBoard){
      alert('è¯¥éš¾åº¦çš„æ•°ç‹¬é¢˜ç›®æš‚æœªå‡†å¤‡å¥½ï¼Œè‡ªåŠ¨è·³è¿‡ã€‚');
      currentIndex++;
      askNext();
      return;
    }

    const wrapper = document.createElement('div');
    wrapper.innerHTML = `
      <p>è¯·å®Œæˆè¿™é“${difficulty}æ•°ç‹¬ï¼Œå®Œæˆåç‚¹å‡»â€œç¡®è®¤â€ç»§ç»­ã€‚</p>
      ${generateSudokuHTML(sudokuBoard)}
      <button id="confirmSudoku">ç¡®è®¤</button>
      <button id="cancelSudoku" style="color:red;">å–æ¶ˆ</button>
    `;
    const popup = document.createElement('div');
    popup.style.position = 'fixed';
    popup.style.top = '50%';
    popup.style.left = '50%';
    popup.style.transform = 'translate(-50%, -50%)';
    popup.style.background = '#fff';
    popup.style.padding = '20px';
    popup.style.border = '2px solid #666';
    popup.style.zIndex = '99999';
    popup.style.fontFamily = "'Press Start 2P', monospace";
    popup.appendChild(wrapper);
    document.body.appendChild(popup);

    document.getElementById('confirmSudoku').onclick = function() {
      if(!validateSudokuInput(popup)) return;
      // è¿™é‡Œæš‚æ—¶ä¸åšå¤æ‚æ•°ç‹¬é€»è¾‘æ ¡éªŒï¼Œé»˜è®¤æ­£ç¡®
      document.body.removeChild(popup);
      answersCorrect++;
      currentIndex++;
      askNext();
    };
    document.getElementById('cancelSudoku').onclick = function() {
      document.body.removeChild(popup);
      alert('å–æ¶ˆç­”é¢˜ï¼Œæ— æ³•å–‚é£Ÿå® ç‰©ã€‚');
      callback(false);
    };
  }
}   
    
      // å® ç‰©éšæœºç§»åŠ¨ï¼ˆç®€å•AIï¼‰
      function movePetRandom() {
        const moves = [
          [0,1], [0,-1], [1,0], [-1,0],
          [1,1], [-1,-1], [1,-1], [-1,1]
        ];
        let validMoves = moves.filter(([dx,dy]) => {
          const nx = pet.x + dx;
          const ny = pet.y + dy;
          return nx >= 0 && nx < gridCount && ny >= 0 && ny < gridCount &&
                 !(nx === player.x && ny === player.y); // ä¸æ’ç©å®¶
        });
        if (validMoves.length === 0) return;
    
        let [dx, dy] = validMoves[Math.floor(Math.random() * validMoves.length)];
        pet.x += dx;
        pet.y += dy;
    
        // å¿ƒæƒ…éšæ—¶é—´æ…¢æ…¢ä¸‹é™
        pet.mood = Math.max(0, pet.mood - 0.1);
    
        updateStatus();
        draw();
      }
    
      // ç›‘å¬é”®ç›˜
      window.addEventListener('keydown', function(e) {
        switch (e.key) {
          case 'ArrowUp': movePlayer(0, -1); break;
          case 'ArrowDown': movePlayer(0, 1); break;
          case 'ArrowLeft': movePlayer(-1, 0); break;
          case 'ArrowRight': movePlayer(1, 0); break;
        }
      });
    
      // å®šæ—¶è®©å® ç‰©åŠ¨èµ·æ¥
      setInterval(movePetRandom, 1000);
    
      // åˆå§‹åŒ–
      updateStatus();
      draw();
    }
    

    // === çš®åˆ’è‰‡æŒ‘æˆ˜ ===
    function startKayakGame() {
      container.innerHTML = `
        <h2>çš®åˆ’è‰‡æŒ‘æˆ˜</h2>
        <p>ç”¨å·¦å³æ–¹å‘é”®æ§åˆ¶çš®åˆ’è‰‡ï¼Œèº²é¿æµªèŠ±ï¼Œæ¥ä½æ°´æ¯å’ŒèƒèŸ¹ï¼è¾¾åˆ° 1500 åˆ†åŠä»¥ä¸Šå¯è·å¾—ç¢ç‰‡å¥–åŠ±ï¼Œè¶…è¿‡ 1500 åˆ†æ¸¸æˆè‡ªåŠ¨ç»“æŸï¼</p>
        <canvas id="kayakCanvas" width="400" height="300"></canvas>
        <div id="message"></div>
        <button class="button" id="restartBtn" style="display:none; margin-top:15px;">é‡æ–°å¼€å§‹</button>
      `;

      const canvas = document.getElementById("kayakCanvas");
      const ctx = canvas.getContext("2d");
      const messageEl = document.getElementById("message");
      const restartBtn = document.getElementById("restartBtn");

      let kayakX = canvas.width / 2 - 20;
      const kayakY = canvas.height - 60;
      const kayakWidth = 40;
      const kayakHeight = 40;

      let items = []; // æµªèŠ±ã€æ°´æ¯ã€èƒèŸ¹
      let gameOver = false;
      let leftPressed = false;
      let rightPressed = false;
      let score = 0;
      let lastItemTime = 0;
      const itemInterval = 700;

      // å®šä¹‰ç‰©å“ç±»å‹
      const ITEM_TYPES = [
        {type: 'wave', color: '#3399ff', size: 30},      // æµªèŠ± è“è‰²åœ†
        {type: 'jellyfish', color: '#cc33ff', size: 25}, // æ°´æ¯ ç´«è‰²æ¤­åœ†
        {type: 'crab', color: '#ff3300', size: 20}        // èƒèŸ¹ çº¢è‰²æ–¹å½¢
      ];

      function createItem() {
        const rand = Math.random();
        let itemType;
        if (rand < 0.6) itemType = ITEM_TYPES[0];
        else if (rand < 0.85) itemType = ITEM_TYPES[1];
        else itemType = ITEM_TYPES[2];

        const x = Math.random() * (canvas.width - itemType.size);
        items.push({x, y: -itemType.size, ...itemType});
      }

      function drawKayak() {
        ctx.fillStyle = '#ff9933';
        ctx.beginPath();
        ctx.ellipse(kayakX + kayakWidth/2, kayakY + kayakHeight/2, kayakWidth/2, kayakHeight/2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#cc6600';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(kayakX + 5, kayakY + kayakHeight/2);
        ctx.lineTo(kayakX + kayakWidth - 5, kayakY + kayakHeight/2);
        ctx.stroke();
      }

      function drawItems() {
        items.forEach(item => {
          ctx.fillStyle = item.color;
          if (item.type === 'wave') {
            ctx.beginPath();
            ctx.arc(item.x + item.size/2, item.y + item.size/2, item.size/2, 0, Math.PI * 2);
            ctx.fill();
          } else if (item.type === 'jellyfish') {
            ctx.beginPath();
            ctx.ellipse(item.x + item.size/2, item.y + item.size/2, item.size/2, item.size/3, 0, 0, Math.PI * 2);
            ctx.fill();
          } else if (item.type === 'crab') {
            ctx.fillRect(item.x, item.y, item.size, item.size);
          }
        });
      }

      function checkCollision() {
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (
            item.y + item.size > kayakY &&
            item.y < kayakY + kayakHeight &&
            item.x + item.size > kayakX &&
            item.x < kayakX + kayakWidth
          ) {
            if (item.type === 'wave') {
              return true; // æ’æµªèŠ± æ¸¸æˆç»“æŸ
            } else {
              if (item.type === 'jellyfish') score += 10;
              else if (item.type === 'crab') score += 20;
              items.splice(i, 1);
              i--;
            }
          }
        }
        return false;
      }

      function drawScore() {
        ctx.fillStyle = '#333';
        ctx.font = '20px monospace';
        ctx.fillText(`å¾—åˆ†: ${score}`, 10, 30);
      }

      function gameLoop(timestamp) {
        if (gameOver) return;

        // æ¸¸æˆè‡ªåŠ¨ç»“æŸæ¡ä»¶
        if (score >= 1500) {
          gameOver = true;
          restartBtn.style.display = 'inline-block';
          messageEl.textContent = `ğŸ‰ æ­å–œï¼ä½ å¾—äº† ${score} åˆ†ï¼Œè¾¾åˆ°æœ€é«˜åˆ†ï¼Œè·å¾— 1 ä¸ªç¢ç‰‡ï¼æ¸¸æˆè‡ªåŠ¨ç»“æŸã€‚`;
          fragmentCount++;
          updateCounter();
          return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#f2d16b';
        ctx.fillRect(0, canvas.height - 40, canvas.width, 40);

        drawKayak();
        drawItems();
        drawScore();

        items.forEach(item => item.y += 4);
        items = items.filter(item => item.y < canvas.height);

        if (!lastItemTime) lastItemTime = timestamp;
        if (timestamp - lastItemTime > itemInterval) {
          createItem();
          lastItemTime = timestamp;
        }

        if (leftPressed && kayakX > 0) kayakX -= 6;
        if (rightPressed && kayakX + kayakWidth < canvas.width) kayakX += 6;

        if (checkCollision()) {
          gameOver = true;
          restartBtn.style.display = 'inline-block';
          if (score >= 1500) {
            messageEl.textContent = `ğŸ’¥ æ’åˆ°æµªèŠ±ï¼Œæ¸¸æˆç»“æŸï¼ä½ å¾—äº† ${score} åˆ†ï¼Œè·å¾— 1 ä¸ªç¢ç‰‡ï¼`;
            fragmentCount++;
            updateCounter();
          } else {
            messageEl.textContent = `ğŸ’¥ æ’åˆ°æµªèŠ±ï¼Œæ¸¸æˆç»“æŸï¼ä½ å¾—äº† ${score} åˆ†ï¼Œæœªè¾¾åˆ° 1500 åˆ†ç¢ç‰‡é—¨æ§›ï¼Œç»§ç»­åŠªåŠ›ï¼`;
          }
        } else {
          score++;
          requestAnimationFrame(gameLoop);
        }
      }

      function restartGame() {
        gameOver = false;
        messageEl.textContent = "";
        restartBtn.style.display = 'none';
        items = [];
        kayakX = canvas.width / 2 - 20;
        score = 0;
        lastItemTime = 0;
        gameLoop();
      }

      window.addEventListener('keydown', e => {
        if (e.key === 'ArrowLeft') leftPressed = true;
        else if (e.key === 'ArrowRight') rightPressed = true;
      });

      window.addEventListener('keyup', e => {
        if (e.key === 'ArrowLeft') leftPressed = false;
        else if (e.key === 'ArrowRight') rightPressed = false;
      });

      restartBtn.addEventListener('click', restartGame);

      gameLoop();
    }

  </script>
</body>
</html>
